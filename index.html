<!DOCTYPE html>
<html lang="en-US">

<head>
    <!-- Title -->
    <title>Loading...</title>

    <!-- Meta -->
    <meta charset=utf-8 />
    <meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no" />

    <!-- OpenGraph -->
    <meta property=og:title content="Your Title" />
    <meta property=og:description content="Your description" />
    <meta property=og:url content="https://kurbos.github.io/bevy-shell-template" />
    <meta property=og:image content="/static/banner.png" />

    <!-- Mobile -->
    <meta name=HandheldFriendly content="True" />
    <meta name=mobile-web-app-capable content="yes" />
    <meta name=apple-mobile-web-app-capable content="yes" />

    <!-- Links -->
    <link rel=canonical href="https://kurbos.github.io/bevy-shell-template/" />
    <link rel=icon type=image/png href=static/favicon.png>

    <!-- Trunk Directives -->
    
    
    
<script type="module" nonce="JAu+67h+XUPT6NfT/lqOMg==">
import init, * as bindings from '/pirate-jam-15/pirate-jam-15-ed10be9eda50af66.js';
const wasm = await init('/pirate-jam-15/pirate-jam-15-ed10be9eda50af66_bg.wasm');


window.wasmBindings = bindings;


dispatchEvent(new CustomEvent("TrunkApplicationStarted", {detail: {wasm}}));

</script>

<link rel="modulepreload" href="/pirate-jam-15/pirate-jam-15-ed10be9eda50af66.js" crossorigin=anonymous integrity="sha384-7iFRAF5vJxQy80FO+2qiERQ3dTX5xIGxNUn0gSLRKBQusUTLu2osBHApKWqaGrDK">
<link rel="modulepreload" href="/pirate-jam-15/snippets/bevy_web_file_drop-14e863d39d362992/src/drop.js" crossorigin=anonymous integrity="sha384-b6MNTTcQSYWrXevZYqPG28s4vV4N/9+4hDQ8x3TERxv6/r+3a/4wUWmLf3XnUmMr">
<link rel="preload" href="/pirate-jam-15/pirate-jam-15-ed10be9eda50af66_bg.wasm" crossorigin=anonymous integrity="sha384-vvBA0inAQjd12Cg61pLeqb+7bJbPw7sd8d0Zr8uGGEZw5ite1QkxTdAwNql34Cm4" as="fetch" type="application/wasm"></head>

<body>
    <!-- The following is a loading modal which is replaced on WASM load. -->
    <style>
        img {
            max-width: 80%;
            max-height: 200px;
        }

        svg {
            width: 100px;
            height: 100px;
        }

        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            background: rgb(40, 40, 40);
            color: rgb(204, 204, 204);
        }
    </style>
    <img src="static/bevy_logo_fill.png" alt="Bevy" />
    <svg version=" 1.1" id="L3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px"
        y="0px" viewBox="0 0 100 100" enable-background="new 0 0 0 0" xml:space="preserve">
        <circle fill="none" stroke="rgb(204, 204, 204)" stroke-width="4" cx="50" cy="50" r="44" style="opacity:0.5;" />
        <circle fill="rgb(40, 40, 40)" stroke="rgb(204, 204, 204)" stroke-width="3" cx="8" cy="54" r="6">
            <animateTransform attributeName="transform" dur="2s" type="rotate" from="0 50 48" to="360 50 52"
                repeatCount="indefinite" />
        </circle>
    </svg>

    
	<script>
		// the following function keeps track of all AudioContexts and resumes them on the first user
		// interaction with the page. If the function is called and all contexts are already running,
		// it will remove itself from all event listeners.
		(function () {
			// An array of all contexts to resume on the page
			const audioContextList = [];

			// An array of various user interaction events we should listen for
			const userInputEventNames = [
				"click",
				"contextmenu",
				"auxclick",
				"dblclick",
				"mousedown",
				"mouseup",
				"pointerup",
				"touchend",
				"keydown",
				"keyup",
			];

			// A proxy object to intercept AudioContexts and
			// add them to the array for tracking and resuming later
			self.AudioContext = new Proxy(self.AudioContext, {
				construct(target, args) {
					const result = new target(...args);
					audioContextList.push(result);
					return result;
				},
			});

			// To resume all AudioContexts being tracked
			function resumeAllContexts(_event) {
				let count = 0;

				audioContextList.forEach((context) => {
					if (context.state !== "running") {
						context.resume();
					} else {
						count++;
					}
				});

				// If all the AudioContexts have now resumed then we unbind all
				// the event listeners from the page to prevent unnecessary resume attempts
				// Checking count > 0 ensures that the user interaction happens AFTER the game started up
				if (count > 0 && count === audioContextList.length) {
					userInputEventNames.forEach((eventName) => {
						document.removeEventListener(eventName, resumeAllContexts);
					});
				}
			}

			// We bind the resume function for each user interaction
			// event on the page
			userInputEventNames.forEach((eventName) => {
				document.addEventListener(eventName, resumeAllContexts);
			});
		})();
	</script>
</body>

</html>